# 密码学（四）：简单的与概率有关的密码学知识

## 基本概率论知识

1\. 概率空间定义：![\\Omega](https://www.zhihu.com/equation?tex=%5COmega) 为样本空间， ![\\mathcal{F}](https://www.zhihu.com/equation?tex=%5Cmathcal%7BF%7D) 为 ![\\Omega](https://www.zhihu.com/equation?tex=%5COmega) 某些子集组成的一个事件域，对任一事件 ![A\\in \\mathcal{F}](https://www.zhihu.com/equation?tex=A%5Cin+%5Cmathcal%7BF%7D) ,定义在![\\mathcal{F}](https://www.zhihu.com/equation?tex=%5Cmathcal%7BF%7D)上的实值函数 ![P\(A\)](https://www.zhihu.com/equation?tex=P%28A%29) 满足

（1）非负性公理：![A\\in \\mathcal{F}](https://www.zhihu.com/equation?tex=A%5Cin+%5Cmathcal%7BF%7D)，则 ![P\(A\)>0](https://www.zhihu.com/equation?tex=P%28A%29%3E0) 。

（2）正则性公理： ![P\(\\Omega\)=1](https://www.zhihu.com/equation?tex=P%28%5COmega%29%3D1) 。

（3）可列可加性公理： ![A_1.A_2...A_n](https://www.zhihu.com/equation?tex=A_1.A_2...A_n) 互不相容，则 ![P\(\\cup_{i=1}^{n}A_i\)=\\sum_{i=1}^{n}{P\(A_i\)}](https://www.zhihu.com/equation?tex=P%28%5Ccup_%7Bi%3D1%7D%5E%7Bn%7DA_i%29%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%7BP%28A_i%29%7D) 。

2\. 全概率公式：![A_1.A_2...A_n](https://www.zhihu.com/equation?tex=A_1.A_2...A_n)为 ![\\Omega](https://www.zhihu.com/equation?tex=%5COmega) 的一个分割，则有 ![P\(A\)=\\sum_{i-1}^{n}{P\(A|B_i\)P\(B_i\)}](https://www.zhihu.com/equation?tex=P%28A%29%3D%5Csum_%7Bi-1%7D%5E%7Bn%7D%7BP%28A%7CB_i%29P%28B_i%29%7D) 。

3\. 贝叶斯公式：![A_1.A_2...A_n](https://www.zhihu.com/equation?tex=A_1.A_2...A_n)为 ![\\Omega](https://www.zhihu.com/equation?tex=%5COmega) 的一个分割，若 ![P\(B\)>0,P\(A_i\)>0](https://www.zhihu.com/equation?tex=P%28B%29%3E0%2CP%28A_i%29%3E0) 。 则![P\(A_i|B\)=\\frac{P\(A_i\)P\(B|A_i\)}{\\sum_{j=1}^{n}P\(A_j\)P\(B|A_j\)}](https://www.zhihu.com/equation?tex=P%28A_i%7CB%29%3D%5Cfrac%7BP%28A_i%29P%28B%7CA_i%29%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bn%7DP%28A_j%29P%28B%7CA_j%29%7D) 。

4\. 随机变量：定义在样本空间上的实值函数 ![X\(\\omega\)](https://www.zhihu.com/equation?tex=X%28%5Comega%29) 称为随机变量。

5\. 数学期望：离散随机变量分布列为 ![p\(x_i\)=P\(X=x_i\)](https://www.zhihu.com/equation?tex=p%28x_i%29%3DP%28X%3Dx_i%29) ，若 ![\\sum_{i=1}^{\\infty}{|x_i|p\(x_i\)}<\\infty](https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5E%7B%5Cinfty%7D%7B%7Cx_i%7Cp%28x_i%29%7D%3C%5Cinfty) ，则称 ![E\(X\)=\\sum_{i=1}^{\\infty}{x_ip\(x_i\)}](https://www.zhihu.com/equation?tex=E%28X%29%3D%5Csum_%7Bi%3D1%7D%5E%7B%5Cinfty%7D%7Bx_ip%28x_i%29%7D) 。连续情况下随机变量密度函数为 ![p\(x\)](https://www.zhihu.com/equation?tex=p%28x%29) ，此时期望为 ![E\(X\)=\\int_{-\\infty}^{\\infty}xp\(x\)dx](https://www.zhihu.com/equation?tex=E%28X%29%3D%5Cint_%7B-%5Cinfty%7D%5E%7B%5Cinfty%7Dxp%28x%29dx) 。

一种常见的计算期望方法：如果 ![F\(x\)](https://www.zhihu.com/equation?tex=F%28x%29) 有一阶连续导数且 ![\\int_{0}^{\\infty}F\(t\)dt](https://www.zhihu.com/equation?tex=%5Cint_%7B0%7D%5E%7B%5Cinfty%7DF%28t%29dt) 存在，那么当 ![n](https://www.zhihu.com/equation?tex=n) 很大时，有 ![\\sum_{k=1}^{\\infty}{F\(\\frac{k}{n}\)}\\approx n\\int_{0}^{\\infty}F\(t\)dt](https://www.zhihu.com/equation?tex=%5Csum_%7Bk%3D1%7D%5E%7B%5Cinfty%7D%7BF%28%5Cfrac%7Bk%7D%7Bn%7D%29%7D%5Capprox+n%5Cint_%7B0%7D%5E%7B%5Cinfty%7DF%28t%29dt) 。

按积分定义展开即可证明。

## 概率分析的例子

之所以需要在密码学中引入概率论，是出于现实的原因，例如这张图：

![](https://pic3.zhimg.com/v2-399698e39e4510aeb29c0eaa299487dc_1440w.jpg)英文字母在文本中出现频率统计表

可以看到一个特点：有些字母出现频率很高，有些字母出现频率很低，频率的差距居然有几十倍之多。如果Alice和Bob正在用凯撒密码通讯，当Eve截获密文时，只要密文的文本量够大，她完全可以统计出规律，不需要尝试直接破解Alice和Bob的通讯内容。

凯撒密码还是过于古早了，在文艺复兴时期的意大利，凯撒密码得到了升级：**维吉尼亚密码（Vigenère cipher）** 。例子如下：

首先每个字母还是与一个数对应：a对应1，b对应2，...z对应26。现在原文是“winter” ，密钥是“cat” ，那么c对应3， “winter”中的w需要后移3位变成z；a对应1， “winter”中的i需要后移1位变成j；t对应20， “winter”中的n需要后移20位，也就是前移6位变成h。当密钥“cat”中字母用完怎么办？重复使用就可以了。再对“winter”中“ter”重新使用一遍密钥“cat”，就会得到对应原文“winter”的密文“zjhwfl”。这种情况下简单的字母频率分析就失效了。

![](https://picx.zhimg.com/v2-e25a8edd03577c27a97b9ca871da5fa1_1440w.jpg)这就是一种维吉尼亚密码的加密工具，字母盘

** _但是概率分析真的就奈何维吉尼亚密码不得了吗？_**

以前还真有人是这么想的，但是事实上，在19世纪的时候，就有人发现：概率分析方法是可以攻破维吉尼亚密码的。原因就在于：密钥是循环使用的。

要破解维吉尼亚密码，首先要做的就是得到密钥的长度，这一点基本上靠尝试，具体方法有很多。不过只要密钥是固定的，破解者总能猜到正确的长度。譬如现在Alice和Bob用维吉尼亚密码通讯，信息被Eve截获了，她猜测密钥长度是5，那么接下来她就可以用上英文字母频率表，如果密钥长度真的是5的话，那么第一个，第六个。第十一个...这些字母组成的新文本，应该是符合某种移位后的英文字母频率表（比如：如果密钥第一个字母是a，那么f就成了新文本中频率最高的字母）。接下来Eve对第二个，第七个，...这些字母做如上操作。只要频率对的上，那么Eve就猜出了密钥长度，同时在对照字母频率表的过程中也得出了密钥。

还有一种经典的Kasiski方法，就是统计字母组合的出现频率，像“the”这样的组合出现频率会极高，如果我们猜对了密钥长度(假设为n），那么密文中的n个字母组合频率将会和原始频率一致。

如果我们猜对了密钥长度，那么文本会更像英文文本，而如果猜错了密钥长度，它会更像随机组合。所以我们需要一种可以量化的度量方法来衡量如下问题：

**一串密文字符，到底是更像英文文本，还是更像随机字母组合？**

这就需要**重合指数（Index of coincidence)** ，它的定义如下：

记文本为 ![s](https://www.zhihu.com/equation?tex=s) ，从文本中随机挑出两个相同字母的概率为 ![IndCo\(s\)](https://www.zhihu.com/equation?tex=IndCo%28s%29) 。算法如下：将拉丁字母与数字对应，a对应1，b对应2，...z对应26。 ![F_1\(s\)](https://www.zhihu.com/equation?tex=F_1%28s%29) 为字符串s中字母a的个数。同理有 ![F_2\(s\),F_3\(s\)...](https://www.zhihu.com/equation?tex=F_2%28s%29%2CF_3%28s%29...) 分别对应b的个数，c的个数...。那么文本中随机挑选两个字母。且它们相同的所有情况总计有 ![C_{F_1\(s\)}^{2}+C_{F_2\(s\)}^{2}+...+C_{F_{26}\(s\)}^{2}](https://www.zhihu.com/equation?tex=C_%7BF_1%28s%29%7D%5E%7B2%7D%2BC_%7BF_2%28s%29%7D%5E%7B2%7D%2B...%2BC_%7BF_%7B26%7D%28s%29%7D%5E%7B2%7D) 种。而随机挑选两个字母总计有 ![C_{F_1\(s\)+F_2\(s\)+...+F_{26}\(s\)}^{2}](https://www.zhihu.com/equation?tex=C_%7BF_1%28s%29%2BF_2%28s%29%2B...%2BF_%7B26%7D%28s%29%7D%5E%7B2%7D) 种。故 ![IndCo\(s\)=\\frac{C_{F_1\(s\)}^{2}+C_{F_2\(s\)}^{2}+...+C_{F_{26}\(s\)}^{2}}{C_{F_1\(s\)+F_2\(s\)+...+F_{26}\(s\)}^{2}}](https://www.zhihu.com/equation?tex=IndCo%28s%29%3D%5Cfrac%7BC_%7BF_1%28s%29%7D%5E%7B2%7D%2BC_%7BF_2%28s%29%7D%5E%7B2%7D%2B...%2BC_%7BF_%7B26%7D%28s%29%7D%5E%7B2%7D%7D%7BC_%7BF_1%28s%29%2BF_2%28s%29%2B...%2BF_%7B26%7D%28s%29%7D%5E%7B2%7D%7D) 。已知随机文本各字母出现概率相同，其 ![Indco\(s\)](https://www.zhihu.com/equation?tex=Indco%28s%29) 为 ![\\frac{1}{26}](https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B26%7D) 。而一个10000字母英文文本的重合指数约为 ![0.0685](https://www.zhihu.com/equation?tex=0.0685)。将文本重合指数与这两个值对比，如果接近英文文本的值，猜测的值就可能是密钥长度。

当得到密钥长度（记为 ![k](https://www.zhihu.com/equation?tex=k) )后，接下来要做的就是确定密钥内容了。实际上这一步可以用对照字母频率表的办法试出来，不过kasiki方法也见效：

为了度量相关性，需要仿照重合指数先定义一个**拟重合指数(Mutual Index of coincidence)** ![MutIndCo\(s\)](https://www.zhihu.com/equation?tex=MutIndCo%28s%29) **,** 记两个文本分别为 ![s,t](https://www.zhihu.com/equation?tex=s%2Ct) 。![F_1\(s\)](https://www.zhihu.com/equation?tex=F_1%28s%29) 为字符串s中字母a的个数。同理有 ![F_2\(s\),F_3\(s\)...](https://www.zhihu.com/equation?tex=F_2%28s%29%2CF_3%28s%29...) 分别对应b的个数，c的个数...。![F_1\(t\)](https://www.zhihu.com/equation?tex=F_1%28t%29) 为字符串s中字母a的个数。同理有 ![F_2\(t\),F_3\(t\)...](https://www.zhihu.com/equation?tex=F_2%28t%29%2CF_3%28t%29...) 分别对应b的个数，c的个数...。那么 ![MutIndCo\(s\)=\\frac{\\sum_{i=1}^{26}{C_{F_{i}\(s\)}^{2}}+C_{F_{i}\(t\)}^{2}}{\\sum_{i=1}^{26}{F_i\(s\)\\sum_{i=1}^{26}F_i\(t\)}}](https://www.zhihu.com/equation?tex=MutIndCo%28s%29%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7B26%7D%7BC_%7BF_%7Bi%7D%28s%29%7D%5E%7B2%7D%7D%2BC_%7BF_%7Bi%7D%28t%29%7D%5E%7B2%7D%7D%7B%5Csum_%7Bi%3D1%7D%5E%7B26%7D%7BF_i%28s%29%5Csum_%7Bi%3D1%7D%5E%7B26%7DF_i%28t%29%7D%7D) 。由于不等式性质，当字母随机分布时拟重合指数会取最小值，所以当拟重合指数较大时，两个文本更有可能符合同种字母分布频率。

将原文本分类：第1个字母，第k+1个字母，2k+1个字母...组成一组，记为 ![s_1](https://www.zhihu.com/equation?tex=s_1) ；第2个字母，第k+2个字母，2k+2个字母...组成一组，记为 ![s_2](https://www.zhihu.com/equation?tex=s_2) ；....第k个字母，第2k个字母...记为 ![s_k](https://www.zhihu.com/equation?tex=s_k) 。假设 ![s_1](https://www.zhihu.com/equation?tex=s_1) 移位 ![\\alpha_1](https://www.zhihu.com/equation?tex=%5Calpha_1) ， ![s_2](https://www.zhihu.com/equation?tex=s_2) 移位 ![\\alpha_2](https://www.zhihu.com/equation?tex=%5Calpha_2) ，... ![s_k](https://www.zhihu.com/equation?tex=s_k) 移位 ![\\alpha_k](https://www.zhihu.com/equation?tex=%5Calpha_k) 。对比不同组之间的拟重合指数，就可以得到一个 ![\\alpha_1,\\alpha_2,...\\alpha_k](https://www.zhihu.com/equation?tex=%5Calpha_1%2C%5Calpha_2%2C...%5Calpha_k) 之间的方程组，例如：

![\\left\\{\\begin{matrix} \\alpha_1+2=\\alpha_2 \\\\ \\alpha_1+4=\\alpha_3  \\\\ ... \\\\ \\alpha_1+11=\\alpha_k  \\end{matrix}\\right.](https://www.zhihu.com/equation?tex=%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D+%5Calpha_1%2B2%3D%5Calpha_2+%5C%5C+%5Calpha_1%2B4%3D%5Calpha_3++%5C%5C+...+%5C%5C+%5Calpha_1%2B11%3D%5Calpha_k++%5Cend%7Bmatrix%7D%5Cright.)

就可以得到26个类似ABCD，BCDE，CDEF这样的密钥，尝试出其中一个正确的就可以了。

## 碰撞算法（Collision Theorem）

这是一个概率论里非常经典的理论：现在有 ![N](https://www.zhihu.com/equation?tex=N) 个不同的数，Alice先从其中取 ![n](https://www.zhihu.com/equation?tex=n) 个互异的数组成一个数组，之后她再从这 ![N](https://www.zhihu.com/equation?tex=N) 个数里随机挑 ![m](https://www.zhihu.com/equation?tex=m) 个数组成另一个数组，若 ![m,n](https://www.zhihu.com/equation?tex=m%2Cn) 均大于 ![\\sqrt{N}](https://www.zhihu.com/equation?tex=%5Csqrt%7BN%7D) ，那么这两个数组有很大概率有相同的数。具体内容如下：

现在有 ![N](https://www.zhihu.com/equation?tex=N) 个不同的数（ ![N](https://www.zhihu.com/equation?tex=N) 足够大），Alice先从其中取 ![n](https://www.zhihu.com/equation?tex=n) 个互异的数组成一个数组，现在Alice需要再选 ![m](https://www.zhihu.com/equation?tex=m) 个数，仅需考虑她新选的这些数里没有一个在先前的 ![n](https://www.zhihu.com/equation?tex=n) 元数组中的情况。此概率为 ![1-\(1-\\frac{n}{N}\)^{m}](https://www.zhihu.com/equation?tex=1-%281-%5Cfrac%7Bn%7D%7BN%7D%29%5E%7Bm%7D) 。进一步。运用不等式 ![e^{-x}>1-x](https://www.zhihu.com/equation?tex=e%5E%7B-x%7D%3E1-x) ，此概率最小值为 ![1-e^{-\\frac{mn}{N}}](https://www.zhihu.com/equation?tex=1-e%5E%7B-%5Cfrac%7Bmn%7D%7BN%7D%7D) 。这个下界大约为 ![0.63](https://www.zhihu.com/equation?tex=0.63) 。

这隐含一个结论：对于一个样本量为 ![N](https://www.zhihu.com/equation?tex=N) 的空间，我们需要 ![\\sqrt{N}](https://www.zhihu.com/equation?tex=%5Csqrt%7BN%7D) 次尝试，这个算法的复杂度是 ![\\mathcal{O}\(\\sqrt{N}\)](https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%28%5Csqrt%7BN%7D%29) 级别的。

### 离散对数碰撞算法（Discrete Logarithm Collision Algorithm）

叙述：已知 ![G](https://www.zhihu.com/equation?tex=G) 是一个群， ![g](https://www.zhihu.com/equation?tex=g) 的阶为 ![N](https://www.zhihu.com/equation?tex=N) ( ![N](https://www.zhihu.com/equation?tex=N)是最小使 ![g^{N}=e](https://www.zhihu.com/equation?tex=g%5E%7BN%7D%3De) 的数）。寻找 ![x](https://www.zhihu.com/equation?tex=x) 使得 ![g^{x}=h](https://www.zhihu.com/equation?tex=g%5E%7Bx%7D%3Dh) 。那么这种离散对数碰撞算法可以使算法的复杂度是 ![\\mathcal{O}\(\\sqrt{N}\)](https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%28%5Csqrt%7BN%7D%29) 级别的。

具体操作：首先设 ![x=y-z](https://www.zhihu.com/equation?tex=x%3Dy-z) ，选取 ![n](https://www.zhihu.com/equation?tex=n) 个不同的数 ![g^{y_1},g^{y_2},...g^{y_n}](https://www.zhihu.com/equation?tex=g%5E%7By_1%7D%2Cg%5E%7By_2%7D%2C...g%5E%7By_n%7D) ，再选取另外 ![n](https://www.zhihu.com/equation?tex=n) 个不同的数 ![hg^{z_1},hg^{z_2},...hg^{z_n}](https://www.zhihu.com/equation?tex=hg%5E%7Bz_1%7D%2Chg%5E%7Bz_2%7D%2C...hg%5E%7Bz_n%7D) 。取 ![n=3\\sqrt{N}](https://www.zhihu.com/equation?tex=n%3D3%5Csqrt%7BN%7D) ，由于碰撞算法的结论，此时，两个数组中有一个相同的概率高于 ![99\\%](https://www.zhihu.com/equation?tex=99%5C%25) 。找到数组中相同的元素即可得出结论。

本质上这种算法是一种用存储空间换效率的算法。

## Pollard's ![\\rho](https://www.zhihu.com/equation?tex=%5Crho) Method

![](https://pic3.zhimg.com/v2-24dbfa2b40653b81455568c097c522e0_1440w.jpg)

Pollard's ![\\rho](https://www.zhihu.com/equation?tex=%5Crho) Method是一种改进过的离散对数碰撞算法，它稍微牺牲了效率，但极大地节省了存储空间。

考虑一个函数 ![f](https://www.zhihu.com/equation?tex=f) , ![x_1=f\(x_0\),x_2=f\(x_1\)...](https://www.zhihu.com/equation?tex=x_1%3Df%28x_0%29%2Cx_2%3Df%28x_1%29...) 。由于群中元素为有限个，所以这个过程必然从某一步开始进入循环，记进入循环前地最大一步为 ![T-1](https://www.zhihu.com/equation?tex=T-1) ，循环周期为 ![M](https://www.zhihu.com/equation?tex=M) 。这个过程由Pollard提出，画出图来很像希腊字母 ![\\rho](https://www.zhihu.com/equation?tex=%5Crho) ，因此得名Pollard's ![\\rho](https://www.zhihu.com/equation?tex=%5Crho) 方法。

这个方法核心在于：我们不需要存储数组中所有数据，只需要存储一部分就可以了。用一个例子来引入这种方法：

记 ![y_1=x_2=ff\(x_0\)](https://www.zhihu.com/equation?tex=y_1%3Dx_2%3Dff%28x_0%29) ， ![y_2=x_4=ffff\(x_0\)...](https://www.zhihu.com/equation?tex=y_2%3Dx_4%3Dffff%28x_0%29...) ，即 ![y_i=x_{2i}](https://www.zhihu.com/equation?tex=y_i%3Dx_%7B2i%7D) ，现在考虑数组 ![\\{ x_n \\}](https://www.zhihu.com/equation?tex=%5C%7B+x_n+%5C%7D) 与 ![\\{ y_n \\}](https://www.zhihu.com/equation?tex=%5C%7B+y_n+%5C%7D) 之间的关系，什么时候有 ![y_i=x_{i}](https://www.zhihu.com/equation?tex=y_i%3Dx_%7Bi%7D) ，即 ![x_{2i}=x_{i}](https://www.zhihu.com/equation?tex=x_%7B2i%7D%3Dx_%7Bi%7D) ?

由于 ![x_j=x_i](https://www.zhihu.com/equation?tex=x_j%3Dx_i) 当且仅当 ![i\\geq T,j\\equiv i \(mod\\ M\)](https://www.zhihu.com/equation?tex=i%5Cgeq+T%2Cj%5Cequiv+i+%28mod%5C+M%29) ，所以 ![M |i](https://www.zhihu.com/equation?tex=M+%7Ci) ，且 ![i\\geq T](https://www.zhihu.com/equation?tex=i%5Cgeq+T) 。即 ![i](https://www.zhihu.com/equation?tex=i) 为第一个比 ![T](https://www.zhihu.com/equation?tex=T) 大且被 ![M](https://www.zhihu.com/equation?tex=M) 整除的数。

这个过程的算法复杂度大约为 ![\\frac{5\\sqrt{N}}{4}](https://www.zhihu.com/equation?tex=%5Cfrac%7B5%5Csqrt%7BN%7D%7D%7B4%7D) ，以下为证明过程：

假设我们在![\\{ x_n \\}](https://www.zhihu.com/equation?tex=%5C%7B+x_n+%5C%7D)中选了前 ![k](https://www.zhihu.com/equation?tex=k) 个数，它们各不相同的概率为： ![Pr\(k个数各不相同\)=\\prod_{i=1}^{k-1} \( \\frac{N-i}{N}\)=\\prod_{i=1}^{k-1}\(1-\\frac{i}{N}\)](https://www.zhihu.com/equation?tex=Pr%28k%E4%B8%AA%E6%95%B0%E5%90%84%E4%B8%8D%E7%9B%B8%E5%90%8C%29%3D%5Cprod_%7Bi%3D1%7D%5E%7Bk-1%7D+%28+%5Cfrac%7BN-i%7D%7BN%7D%29%3D%5Cprod_%7Bi%3D1%7D%5E%7Bk-1%7D%281-%5Cfrac%7Bi%7D%7BN%7D%29) 。再利用估计当 ![t](https://www.zhihu.com/equation?tex=t) 很小时，![1-t\\approx e^{-t}](https://www.zhihu.com/equation?tex=1-t%5Capprox+e%5E%7B-t%7D) 。此时 ![\\prod_{i=1}^{k-1}\(1-\\frac{i}{N}\)\\approx\\prod_{i=1}^{k-1}e^{-\\frac{i}{N}}\\approx e^{-\\frac{k^2}{2N}}](https://www.zhihu.com/equation?tex=%5Cprod_%7Bi%3D1%7D%5E%7Bk-1%7D%281-%5Cfrac%7Bi%7D%7BN%7D%29%5Capprox%5Cprod_%7Bi%3D1%7D%5E%7Bk-1%7De%5E%7B-%5Cfrac%7Bi%7D%7BN%7D%7D%5Capprox+e%5E%7B-%5Cfrac%7Bk%5E2%7D%7B2N%7D%7D) （最后一步用了一个近似 ![\\sum_{i=1}^{k-1}{i}\\approx\\frac{k^2}{2}](https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5E%7Bk-1%7D%7Bi%7D%5Capprox%5Cfrac%7Bk%5E2%7D%7B2%7D) )。

接下来考虑这样一种情况，如果下一个选择的数 ![x_k](https://www.zhihu.com/equation?tex=x_k) 恰好是我们之前选择的数组 ![\\{x_0,x_1...x_{k-1}\\}](https://www.zhihu.com/equation?tex=%5C%7Bx_0%2Cx_1...x_%7Bk-1%7D%5C%7D) 中的一个元素。这个概率为 ![\\frac{k}{N}](https://www.zhihu.com/equation?tex=%5Cfrac%7Bk%7D%7BN%7D) 。将这个概率与数组 ![\\{x_0,x_1...x_{k-1}\\}](https://www.zhihu.com/equation?tex=%5C%7Bx_0%2Cx_1...x_%7Bk-1%7D%5C%7D)元素互异的概率相乘，即可得在第 ![k](https://www.zhihu.com/equation?tex=k) 步时“碰撞”（即取新数组时，新数组中第一个与老数组相同的元素）成功的概率。这个概率为 ![\\frac{k}{N}e^{-\\frac{k^2}{2N}}](https://www.zhihu.com/equation?tex=%5Cfrac%7Bk%7D%7BN%7De%5E%7B-%5Cfrac%7Bk%5E2%7D%7B2N%7D%7D) 。

由数学期望的定义： ![E\(碰撞成功\)=\\sum_{k\\geq1}^{}{\\frac{k^2}{N}e^{\\frac{k^2}{2N}}}](https://www.zhihu.com/equation?tex=E%28%E7%A2%B0%E6%92%9E%E6%88%90%E5%8A%9F%29%3D%5Csum_%7Bk%5Cgeq1%7D%5E%7B%7D%7B%5Cfrac%7Bk%5E2%7D%7BN%7De%5E%7B%5Cfrac%7Bk%5E2%7D%7B2N%7D%7D%7D) 。定义函数 ![F\(t\)=t^2e^{-\\frac{t^2}{2}}](https://www.zhihu.com/equation?tex=F%28t%29%3Dt%5E2e%5E%7B-%5Cfrac%7Bt%5E2%7D%7B2%7D%7D) ，此时 ![E\(碰撞成功\)=\\sum_{k\\geq1}^{}{\\frac{k^2}{N}e^{\\frac{k^2}{2N}}}=\\sum_{k\\geq1}^{}F\(\\frac{k}{\\sqrt{N}}\)\\approx\\sqrt{N}\\int_{0}^{\\infty}t^2e^{-\\frac{t^2}{2}}dt\\approx 1.25\\sqrt{N}](https://www.zhihu.com/equation?tex=E%28%E7%A2%B0%E6%92%9E%E6%88%90%E5%8A%9F%29%3D%5Csum_%7Bk%5Cgeq1%7D%5E%7B%7D%7B%5Cfrac%7Bk%5E2%7D%7BN%7De%5E%7B%5Cfrac%7Bk%5E2%7D%7B2N%7D%7D%7D%3D%5Csum_%7Bk%5Cgeq1%7D%5E%7B%7DF%28%5Cfrac%7Bk%7D%7B%5Csqrt%7BN%7D%7D%29%5Capprox%5Csqrt%7BN%7D%5Cint_%7B0%7D%5E%7B%5Cinfty%7Dt%5E2e%5E%7B-%5Cfrac%7Bt%5E2%7D%7B2%7D%7Ddt%5Capprox+1.25%5Csqrt%7BN%7D) 。

### Pollard's ![\\rho](https://www.zhihu.com/equation?tex=%5Crho) Method的具体操作

pollard给出了一个具体的函数 ![f](https://www.zhihu.com/equation?tex=f) 来对 ![F_p](https://www.zhihu.com/equation?tex=F_p) 内的元素变换：

![f\(x\)=\\left\\{\\begin{matrix} gx, 0\\leq x<p/3 \\\\ \\ \\ \\ \\ \\ x^2, p/3\\leq x <2p/3 \\\\ hx, 2p/3\\leq x <p  \\end{matrix}\\right.](https://www.zhihu.com/equation?tex=f%28x%29%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D+gx%2C+0%5Cleq+x%3Cp%2F3+%5C%5C+%5C+%5C+%5C+%5C+%5C+x%5E2%2C+p%2F3%5Cleq+x+%3C2p%2F3+%5C%5C+hx%2C+2p%2F3%5Cleq+x+%3Cp++%5Cend%7Bmatrix%7D%5Cright.)

这个函数对大部分情况都是有效的，但是目前还没人给出证明，也就是说这是一个经验函数。记 ![x_0=1](https://www.zhihu.com/equation?tex=x_0%3D1) ，那么 ![x_n=\(f\\circ f...\\circ f\)x_0=g^{\\alpha_i}h^{\\beta_i}](https://www.zhihu.com/equation?tex=x_n%3D%28f%5Ccirc+f...%5Ccirc+f%29x_0%3Dg%5E%7B%5Calpha_i%7Dh%5E%7B%5Cbeta_i%7D) 。其中指标 ![\\alpha_{i},\\beta_{i}](https://www.zhihu.com/equation?tex=%5Calpha_%7Bi%7D%2C%5Cbeta_%7Bi%7D) 变化如下：

![\\alpha_{i+1}=\\left\\{\\begin{matrix} \\ \\ \\alpha_{i}+1, 0\\leq x<p/3 \\\\ \\ \\ \\ \\ 2\\alpha_{i}, p/3\\leq x <2p/3 \\\\ \\alpha_i, 2p/3\\leq x <p \\end{matrix}\\right.](https://www.zhihu.com/equation?tex=%5Calpha_%7Bi%2B1%7D%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D+%5C+%5C+%5Calpha_%7Bi%7D%2B1%2C+0%5Cleq+x%3Cp%2F3+%5C%5C+%5C+%5C+%5C+%5C+2%5Calpha_%7Bi%7D%2C+p%2F3%5Cleq+x+%3C2p%2F3+%5C%5C+%5Calpha_i%2C+2p%2F3%5Cleq+x+%3Cp+%5Cend%7Bmatrix%7D%5Cright.)

![\\beta_{i+1}=\\left\\{\\begin{matrix} \\ \\ \\beta_{i}+1, 0\\leq x<p/3 \\\\ \\ \\ \\ \\ 2\\beta_{i}, p/3\\leq x <2p/3 \\\\ \\beta_i, 2p/3\\leq x <p \\end{matrix}\\right.](https://www.zhihu.com/equation?tex=%5Cbeta_%7Bi%2B1%7D%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D+%5C+%5C+%5Cbeta_%7Bi%7D%2B1%2C+0%5Cleq+x%3Cp%2F3+%5C%5C+%5C+%5C+%5C+%5C+2%5Cbeta_%7Bi%7D%2C+p%2F3%5Cleq+x+%3C2p%2F3+%5C%5C+%5Cbeta_i%2C+2p%2F3%5Cleq+x+%3Cp+%5Cend%7Bmatrix%7D%5Cright.)

再记 ![y_i=x_{2i}=g^{\\gamma_i}h^{\\delta_i}](https://www.zhihu.com/equation?tex=y_i%3Dx_%7B2i%7D%3Dg%5E%7B%5Cgamma_i%7Dh%5E%7B%5Cdelta_i%7D) ，此时 ![g^{\\alpha_i}h^{\\beta_i}=g^{\\gamma_i}h^{\\delta_i}](https://www.zhihu.com/equation?tex=g%5E%7B%5Calpha_i%7Dh%5E%7B%5Cbeta_i%7D%3Dg%5E%7B%5Cgamma_i%7Dh%5E%7B%5Cdelta_i%7D) ，有 ![u\\equiv \\alpha_i-\\gamma_i\(mod \\ p-1\)](https://www.zhihu.com/equation?tex=u%5Cequiv+%5Calpha_i-%5Cgamma_i%28mod+%5C+p-1%29) ， ![v\\equiv \\beta_i-\\delta_i\(mod \\ p-1\)](https://www.zhihu.com/equation?tex=v%5Cequiv+%5Cbeta_i-%5Cdelta_i%28mod+%5C+p-1%29) 。即在 ![F_p](https://www.zhihu.com/equation?tex=F_p) 中有 ![g^u=h^v](https://www.zhihu.com/equation?tex=g%5Eu%3Dh%5Ev) ，即 ![v\\cdot log_g\(h\)\\equiv u\( mod \\ p-1\)](https://www.zhihu.com/equation?tex=v%5Ccdot+log_g%28h%29%5Cequiv+u%28+mod+%5C+p-1%29) 。接下来这个问题就转化成了之前的离散对数问题，非常容易求解了。

尝试例子 ![19^t\\equiv 24717 \(mod \\ 48611\)](https://www.zhihu.com/equation?tex=19%5Et%5Cequiv+24717+%28mod+%5C+48611%29) 。

答案是37689

## 代码部分

相关代码可以去我的Github查看：

[GitHub - Summer-worm/Cryptography: Some works I do when I study cryptography](https://link.zhihu.com/?target=https%3A//github.com/Summer-worm/Cryptography)