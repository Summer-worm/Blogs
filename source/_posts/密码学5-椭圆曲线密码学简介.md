---
title:  密码学（五）：椭圆曲线密码学简介
date: 2025-09-09
categories:
  - Mathematics
mathjax: true
---

## 椭圆曲线简介

符合以下方程的代数曲线被称作椭圆曲线：

$Y^2=X^3+AX+B$

如图：

![](https://pic2.zhimg.com/v2-0d95a3b6b63f8f49b72a0b0a70db9fa7_1440w.jpg)

**为什么要在椭圆曲线上做密码学？**

因为可以在椭圆曲线上构造“加法”。在椭圆曲线 $E$上取两点$P,Q$，连接$PQ$交$E$于$R$，与$R$有相同横坐标的点记为$R^{'}$。记这种运算为$P\oplus Q=R^{'}$。如果是过$P$做切线，记为$P\oplus P=2P=R^{’}$ 。

![](https://pic1.zhimg.com/v2-3db9cddd7e4af8df90cbf021b326d194_1440w.jpg)![](https://picx.zhimg.com/v2-b454ad074467ffbfe37d255668f03911_1440w.jpg)

还有一种特殊情况，当这条直线垂直于x轴时，其与椭圆曲线交点数目是少于3个的，此时引入一个元素 $\mathcal{O}$ 。这个$\mathcal{O}$ 就是这种加法定义里的零元素。 $\mathcal{O}\oplus P=P\oplus\mathcal{O}=P$ 。

![](https://pic1.zhimg.com/v2-db51012031fe89eba41f529b48ed55ac_1440w.jpg)

图中椭圆曲线加法即为 $P\oplus P^{'}=\mathcal{O}$ 。这种加法满足交换律和结合律。易于验证这些元素和加法构成一个群。具体计算方法就是根据已知点写出直线方程，与椭圆曲线联立后计算新点坐标。

以下公式即为推导结果：

$P,Q$为$(x_1,y_1),(x_2,y_2)$，记$P\oplus Q$ 为 $(x_3,y_3)$，首先计算直线斜率 $\lambda=\left\{\begin{array}{cc}     \frac{y_2-y_1}{x_2-x_1} ,P\ne Q \\\\      \frac{3x_1^2+A}{2y_1} ,P=Q\\\\  \end{array}\right.$ ，之后代入即得 $x_3=\lambda^2-x_1-x_2,y_3=\lambda(x_1-x_3)-y_1$ 。

## 有限域上的椭圆曲线

对于奇素数p与椭圆曲线 $E：Y^2=X^3+AX+B,(A\in F_p,B\in F_p,4A^3+27B\ne 0\)$ ，定义在 $F_p$上的点集全体即为$\left\{ (x,y)|x,y\in F_p ,y^2=x^3+Ax+B \right\}\cup \left\{ \mathcal{O} \right\}$ 。

$4A^3+27B$ 是一元三次方程的判别式，令其不为0是为了防止曲线出现奇异点。有关判别式的理论可查阅”三次方程“相关条目，这种方程的判别式研究早在文艺复兴时就已经出现。

但是计算过程中需要加上模p意义下的四则运算与寻找二次剩余这一步。理论可见：

密码学（一）：基础数学知识与密码学的简单介绍 

具体例子如下：

考虑 $Y^2=X^3+3X+8$，先取$X=1$，即$Y^2=12$。由于$5^2\equiv 8^2 \equiv 12 \\ (mod\\ 13)$ 。可知此时有两个点 $(1,5),(1,8)$$。代入 $X=9$ 后，可验证 $(9,6),(9,7)$ 也在其上。

现在记 $P=(1,5),Q=(9,7)$，那么$\lambda=\frac{8-7}{1-9}=\frac{1}{-8}=\frac{1}{5}=8$，即得 $x_3=54=2, y_3=-16=10, P\oplus Q=(2,10)$ 。

所有点见如下表格：

![](https://pic3.zhimg.com/v2-7fe59a0193b843ea8c2c7457f851c49c_1440w.jpg)

易于验证表格内点与椭圆曲线$F_{13}$上的加法构成一个有限交换群。

接下来考虑在模p意义下会出现多少这样的点。从理论中我们得知p的完全剩余系中应有一半有二次剩余，每个有二次剩余的数对应两个点，再加上零点，所以应该有p+1个点。但是改变椭圆曲线的系数可能正好出现Y被整除的情况，此时点的数目就会存在一个波动。Hasse给出了一个范围估计，此处不加证明直接列出：

记点的个数为 $\#(F_p)] ，$\#(F_p)=p+1-t_p, \left| t_p \right| \leq 2\sqrt{p}$ 。 $t_p$被称作 $E/F_p$的弗罗比尼乌斯迹(Frobenius trace)。

## 椭圆曲线上的离散对数算法（ECDLP）

之前定义的椭圆曲线上的加法在这种离散对数算法中的地位，就是实数域的乘法在普通离散对数算法中的地位。为了计算的更加快速方便，还是需要运用一些处理技巧，例如知名的加倍累加（Double-and-Add Algorithm）方法。

### **加倍累加法（Double-and-Add Algorithm)**

具体操作就是对一个十进制的数二进制化，其实就是将这个数拆成2的幂次相加的形式，其实就是将这个数写成二进制形式。

举一个例子： $947=2^9+2^8+2^7+2^5+2^4+2+1$。为了让这个表达式更短，**可以考虑一个常用化简式** $2^k-1=2^{k-1}+2^{k-2}+...+2+1$。那么此时可化简原表达式为$947=2^{10}-2^6-2^4+2+1$。

这种操作的好处如下：在取定初始点$P$后，计算 $nP$时， $n$可以表示为$n_0+n_1\times 2+n_2\times 2^2+...+n_k\times 2^k$ 。那么最多只需要做 $n_1+n_2+...+n_k$次乘法与$
k$次加法即可，同时乘法每次都是乘2，写程序也很方便。很大程度上提升了运算速度与运算效率（这里如果运用化简式，效率会更高，实际上乘法和加法运算总数大约为$\frac{4}{3}k+1$次， $k=log\\ n+1$ ）。

### 复杂度问题

这里需要用到概率论密码学里的collision方法：密码学（四）：简单的与概率有关的密码学知识 

选取两个序列，分别记为 $j_1P ,j_2P,...,j_rP$与$k_1P+Q ,k_2P+Q,...,k_rP+Q$。对这两个序列采用碰撞算法，当 $r$足够大时能找到 $(k-j)P=Q$
的概率就会接近1。由于是在 $F_p$ 中运算，算法复杂度就是 $\sqrt{p}$ 。

**接下来就是椭圆曲线密码学优越性的地方了** ：**我们目前知识与技术条件下该算法复杂度下限就是**$O(\sqrt{p})$ 。这就使得其相较于RSA有了破解难度下的优越性，设计者可以选用更小的p值，在同样的安全性下所占资源更少。

这是因为我们还没有充分了解椭圆曲线数域的性质。不像实数域上的RSA算法，只要p满足一些特殊的性质，比如p-1可以被分解成很多小因子，那么RSA的DLP就可以迅速破解。在椭圆曲线的ECDLP中，既使p-1可以通过某些方式迅速分解，也没什么用。（当然只是目前这样）。

但这不代表椭圆曲线的ECDLP就一定全方位优于RSA的DLP，如果选了一些不对劲的 $F_p$ ，有可能ECDLP是不堪一击的，详情见后文。

## 椭圆曲线上的密码构建

### 椭圆曲线上的Diffie-Hellman密码系统：

Alice和Bob共同选定 $E(F_p)$ 与一个起始点$P\in E(F_p)$ ，同时Alice选定自己的私钥 $n_A$，Bob选定自己的私钥 $n_B$ ，之后Alice计算 $Q_A=n_AP$ ，Bob计算 $Q_B=n_BP$ 。两人交换$Q_A,Q_B$ 再分别计算$n_BQ_A$ 与 $n_AQ_B$ 。

如果Eve想破解Alice和Bob的问题，她可以去解决$Q_A=n_AP$ 这种ECDLP问题，或者她可以直接利用Diffie-Hellman密码系统的漏洞绕开DLP问题。很不幸，这种漏洞是该密码系统的痼疾，并未随着数域改变而消失。这就是解决Diffie-Hellman问题（DHP）与DLP不等价。在RSA中，DHP表示为已知 $g^a(mod\\ p),\\ g^b(mod\\ p)$ 求 $g^{ab}(mod\\ p)$ 。在这里，ECDHP表示为已知 $n_AP,n_BP$求 $n_An_BP$ 。解决DLP肯定可以解决DHP，但解决了DHP未必能解决DLP。

### 椭圆曲线上的Elgamal密码系统：

Alice和Bob共同选定$E(F_p)$ 与一个起始点 $$P\in E(F_p)$ ，同时Alice选定自己的私钥 $n_A$，Bob选定自己的密文$
M$，之后Alice将 $Q_A=n_AP$ 当作公钥发布，Bob再随便选一个数 $k$ 并计算 $C_1=kP, \\ C_2=M+kQ_A$ 。之后Bob将 $(C_1,C_2)$发给Alice，Alice计算 $C_2-n_AC_1=M+kQ_A-n_A(kP\)=M+k(n_AP)-n_A(kP)=M$ 得出Bob传递的信息。

为了提升安全性，Bob还可以只送出x的坐标，但是由于Alice要进行坐标轴的计算，所以Bob需要再添加一个信息来表示y的符号。例如当y小于 $\frac{p}{2}$ 时用0，另一种情况用1。

## Lenstra的椭圆曲线因数分解法

这种方法比实数域上的那套分解法弱，但也是较为实用的法。这种方法思想与Pollad's p-1 method类似： 密码学（三）RSA算法以及一些因数分解法 -

假设我们要分解 $N=pq$，举例说明：记$N=187， 187=11\\times 17$ 。考虑曲线 $Y^2=X^3+3X+7$与点$
P(38,112)$ ，在 $F_{187}$ 上计算。易于验证2P与3P都是可以计算的，但是当计算3P+2P=5P的情况时，就会发现此时不存在 $Y^2\equiv 1(mod\\ 187)$ 的情况，此时 $Y^2=11$,那么11就是187的一个因数。

该算法具体流程如下：

  1. 需要分解数N，选定A，a，b；其中a，b在N的完全剩余系中。
  2. 选定$P=(a,b)$， $B\equiv b^2-a^3-A\cdot a (mod\\ N)$ ，选定椭圆曲线 $E：Y^2=X^3+AX+B$
  3. 进行循环，从j=2开始，记Q=jP，若Q可计算，那么记j=j+1，重复此过程。若此过程失败，那么我们就找到了N的一个因数d，但要是d=N怎么办呢？那就需要挑一条新曲线了。

从算法复杂度上分析，当N存在较小因子p时，该算法复杂度和数域筛法的复杂度是一个量级的。

## 定义在 $F_{2^{k}}$ 上的椭圆曲线密码学与广义魏尔斯特拉斯方程

之前谈过p需要是奇素数，现在考虑推广的情况。首先就是p=2的情况，但此时椭圆曲线一共就5个点，没有什么实用价值，所以需要考虑 $F_{2^k}$ 的情况。

但这么做首先就面临一个问题：此时模运算为 $2=0$ ，这种运算下所有的椭圆曲线的判别式都是0，换言之原来的椭圆曲线因为奇异点问题都用不了。

这时就需要引入**广义魏尔斯特拉斯方程** ： $E：Y^2+a_1XY+a_3Y=X^3+a_2X^2+a_4X+a_6$。这是椭圆曲线的直接推广，其判别式如下：

$b_2=a_1^2+4a_2, b_4=2a_4+a_1a_3,b_6=a_3^2+4a_6,b_8=a_1^2a_6+4a_2a_6-a_1a_3a_4+a_2a_3^2-a_4^2$。$\Delta=-b_2b_8^2-8b_4^2-27b_6^2+9b_2b_4b_6$。

此时对于同样的坐标x，y有两个值，两点分别为$(x,y),(x,-y-a_1x-a_3)$。其加法如下：记 $P=(x_1,y_1),Q=(x_2.y_2)$ 。那么 $x(P+Q)=\lambda^2+a_1\lambda-a_2-x_1-x_2$，$
x(2P)=\frac{x_1^4-b_4x_1^2-2b_6x_1-b_8}{4x_1^3+b_2x_1^2+4b_4x_1+b_6}$

这么做有如下实际意义：计算机就是用二进制表示的，所以这种做法不仅会让程序更简洁，还会让效率得以提升。但是提升的效率总会带来安全性降低的问题，比如当 $j\left| \right. k$ 时，就可以采用 $F_{2^j}$是 $F_{2^k}$ 子域的性质来简化运算。所以实际应用中一般选择素数k。更重要的是， $F_{2^k}$ **这种数域在加密过程中可以使用弗罗比尼乌斯映射(Frobenius map)去做** 。这种映射比加倍累加法要快很多，可以极大地降低加密者的资源消耗。

### 弗罗比尼乌斯映射：

定义如下：$\tau：F_{p^k}\rightarrow F_{p^k}, \alpha \rightarrow \alpha^p$性质如下$\tau(\alpha+\beta)=\tau(\alpha)+\tau(\beta), \\ \tau(\alpha\beta)=\tau(\alpha)\tau(\beta)$。注意此时p=2，在模p运算意义下展开即证。$\tau(P)=(\tau(x),\tau(y))$。

这种映射的威力在于可以直接把$F_{2^k}$ 上的问题化简到 $F_2$ 上处理，例如在广义魏尔斯特拉斯方程上的 $Y^2+a_1XY+a_3Y-X^3-a_2X^2-a_4X-a_6=0$ 可以直接化为 $\tau(Y)^2+a_1\tau(X)\tau(Y)+a_3\tau(Y)-\tau(X)^3-a_2\tau(X)^2-a_4\tau(X)-a_6=0$。

这种情况下估计点数的Hasse定理如下，证明很复杂，直接写结论：

记$\left|\alpha \right|=\left| \beta \right|=\sqrt{p}$，对正整数k有$\#(F_{p^k})=p^k+1-\alpha^k-\beta^k$。记 $t=p+1-\#(F_{p^k})$ 。对弗罗比尼乌斯映射 $\tau$有 $\tau(\tau(Q))-t\cdot\tau(Q)+p\cdot Q=\mathcal{O}$ 。

可以使用跟加倍累加法完全一样的技巧运用弗罗比尼乌斯映射，比如将n拆成 $n=a_0+a_1\tau+...+a_k\tau^k$。接下来可以使用 $\tau^2-t\tau+p$ 的多项式化简原式。

可以尝试如下代码问题：

1.尝试写出椭圆曲线上的加法，并生成$y^2=x^3+5x+12$在$F_{13}$上的所有点（包括零点），尝试用离散对数算法写出它们的关系。

2. 尝试用Lenstra方法分解如下几个数516083，1833779393，13487843290022369713。

可以参考我的Github: [Summer-worm/Cryptography: Some works I do when I study cryptography (github.com)](https://link.zhihu.com/?target=https%3A//github.com/Summer-worm/Cryptography)

本文是之前学椭圆曲线密码学的笔记，记述了比较初级的理论和应用，之后有空会写新文章讲些高级东西。