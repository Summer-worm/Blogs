---
title:  密码学（六）：格理论简介
date: 2025-09-09
categories:
  - Mathematics
mathjax: true
---
**什么是格？它的来源又是什么？我们为什么要用它来做密码？**

**用例子来说明这些问题。**

## 1. 两个简单例子：

第一个例子：还是从经典的同余结构入手，Alice和Bob利用大数与同余来传递信息。

首先Alice需要找到一个足够大的正整数 $p$ 并对外公布，之后她再选择两个正整数$f，q$作为私钥，其中 $f<\sqrt\frac{q}{2}, \sqrt\frac{ q}{4}<g<\sqrt\frac{ q}{2}$ 。而且f与
qg的最大公因数为1，即gcd(f,qg)=1。（为什么要对 $f,g$ 做如下限制呢？这个原因之后会给出）。之后Alice计算 $h \equiv f^{-1}g(mod \\ q)$ ，并将 $h$对外公布。

Bob手头有一个原文$m$，这个$m$满足如下不等式 $0<m<\sqrt\frac{q}{4}$ 。他想要对原文进行加密，首先他需要随机选择一个正整数 $r$ 满足 $0<r<\sqrt\frac{q}{2}$，之后计算密文 $e \equiv rh+m (mod \\ q)$ 。

Alice拿到密文之后，需要做如下解密流程：

首先计算 $a \equiv fe (mod \\ q)$ ，由于 $h \equiv f^{-1}g(mod \\ q)$ 。此时 $fe\equiv frh+fm \equiv gr+fm(mod\\ q)$ 。

接着计算 $b \equiv f^{-1}a (mod \\ g)$ ，这里的 $f^{-1}$ 满足 $ff^{-1}\equiv 1 (mod \\ g)$ ，因此 $f^{-1}a\equiv f^{-1}gr+f^{-1}fm \equiv m (mod \\ g)$ 。

接下来解释前面对于 $f,g,r,m$的不等式限制，对于$gr+fm$有 $gr+fm<\sqrt\frac{q}{2}\sqrt\frac{q}{2}+\sqrt\frac{q}{2}\sqrt\frac{q}{4}<q$ 。所以计算出来的$a$就是确切值，而不是同余之后的值。接下来由于$m<\sqrt\frac{q}{4}<g $ ，计算出来的 $b$就是确切的原文 $m$ 。

**如何攻破这个密码系统**

现在老解密家Eve想要攻破这个系统，目前她知道的信息是公布在外的$q$ 与 $h$ 以及密文 $e$ 。她要通过什么手段去得到原文呢？如果暴力列举的话，计算复杂度是 $\mathcal{O}(q)$，这显然非Eve所愿。观察密码系统可知其关键在于 $h \equiv f^{-1}g(mod \\ q)$ ，也就是 $fh \equiv g(mod \\ q)$ 。如果Eve能找到一组 $F,G$使得$Fh \equiv G(mod \\ q)$ 。那么这组 $F,G$就有可能是密码系统的私钥$f,g$。这里我们将$Fh \equiv G(mod \\ q)$ 写成等式形式$Fh=G+qR$,再将其变为如下形式：$F(1,h)-R(0,q)=(F,G)$。

这就是线性代数里常见的 $w=a_1 v_1+a_2 v_2$的形式，在这个问题中，$(1,h),(0,q)$线性无关，正好做为空间的一组基。由于系数和向量的所有分量都是整数，所以我们实际是在格点（Lattice）上进行线性组合，这就是格理论的名字由来。我们将一个同余的计算问题，转化成了在格点上寻找恰当线性组合找到对应向量的问题。

在这个问题中，采用线性代数的方法，Eve可以在短时间内攻破Alice和Bob的密码系统，这也是格密码学的优势所在。

### 子集和问题(Subset-sum problem)与Knapsack密码系统

假设有一组正整数$(M_1, M_2,...M_n)$，现在再给一个正整数$S$，能否找到一种方法使得$S$可以表示为这组正整数的某个子集中的所有元素之和。例如给定一组数$(1,3,8)$ ，那么4=1+3，4就存在表示方法，而5就不行。这个问题就叫子集和问题。

其实，就是能否找到一个$x=(x_1,x_2,...x_n)$，对每个$x_i$均有$x_i=0$或$x_i=1$使得$S=\sum_{i=1}^{n}{x_i M_i}$。

可以利用这种性质来构建一个密码系统，其中$x$为原文，Bob加密后将$S$发给Alice，如果Alice手上有一种方法能将 $S$ 快速解密出来，那么这个方法就适用。但问题是方法是通用的，Alice会的Eve也会，该怎么办呢？这个时候Alice就可以把她的那组正整数藏起来做为私钥，这样Eve就没办法了。常见情况是这样的一组正整数 $(r_1, r_2,...r_n)$ ，对于每个 $r_i$有 $r_{i+1}>2r_i$。这样的一组数被称作Super-increasing Sequence。解决这种序列上的子集和问题非常简单，首先找到 $r_i$满足 $r_i<S<r_{i+1}$，计算出 $S-r_i$ 后再不断重复以上过程即可。由数学归纳法可证结论成立。

但是，这个方法有一个问题，为了确保安全性，Alice和Bob需要选取非常长非常大的正数序列，这使得加密和解密过程极度臃肿。但要是选一些小序列，那么1982年提出的LLL方法为攻击这种密码形式提供了一个快捷的做法，这使得这种密码系统不再实用。

## 2. 格（Lattice）的定义

这里的内容主要是线性代数，相对而言比较基础。

现有一组线性无关的向量$v_1,v_2,...v_n \in R^{m}$。记它们张成的空间$L=\{a_1 v_1+a_2 v_2+...+a_n v_n| a_1, a_2,...a_n \in Z  \}$，那么 $L$ 就是一个格(Lattice)。

现在我们考虑$L$ 的另一组基 $w_1,w_2,...w_n \in R^{m}$。由线性代数的常规结论，我们有：$$ \left( \begin{aligned} 
w_1 &= a_{11} v_1 + a_{12} v_2 + \dots + a_{1n} v_n \\ 
w_2 &= a_{21} v_1 + a_{22} v_2 + \dots + a_{2n} v_n \\ 
\vdots &= \vdots \\
 w_n &= a_{n1} v_1 + a_{n2} v_2 + \dots + a_{nn} v_n \end{aligned} \right. $$

记

$$
A=\left(     \begin{array}  {cccc|cccc}    
a_{11} & a_{12} & \cdot & a_{1n} \\      
a_{21} & a_{22} & \cdot & a_{2n} \\   
\vdots & \vdots & \vdots &\vdots \\  
a_{n1} & a_{n2} & \cdot & a_{nn}
\end{array} \right)
$$，

由于$A$中的每个元素都是整数，易知 $det(A)$ 也是整数。由线性代数常见结论， $v_1,v_2,...v_n$ 也可由 $w_1,w_2,...w_n$表示。结合格相关性质，可知$
det(A^{-1})$ 也是整数，结合 $AA^{-1}=I$。可知 $det(A)=\pm 1$。 即若在格中进行基变换，那么变换矩阵行列式的绝对值为1 。

其实从群的角度来看，格还有一个定义： $R^{m}$ 上任一离散的加法子群与格是等价的，这一点很好证明。

### 格的基本域(Fundamental domain)

设 $L$ 是一个n维格，其基向量为 $v_1,v_2,...v_n$ 。那么记 $L$ 的基本域 $\mathcal{F}(v_1,v_2,...v_n)$ 为：

$\mathcal{F}(v_1,v_2,...v_n)=\{ t_1 v_1+t_2 v_2+...+t_n v_n: 0\leq t_1 <1\}$ 。

记 $det(L)=Vol(\mathcal{F})$ 。

如图：

![](https://pic4.zhimg.com/v2-240e35556fb88f2d409faadc65fb7cf3_1440w.jpg)

**定理：对于格内的任何一个向量$w$，都可以将其分解为$w=t+v$的形式，其中$t \in \mathcal{F}, v \in L$ ，并且这种分解方法是唯一的。**

证明：将 $w$表示为$w=\alpha_1 v_1+\alpha_2 v_2+...+\alpha_n v_n$ 的形式，再将每个 $\alpha_i$分解为$
\alpha_i=t_i+a_i$ 的形式。此时， $w=(t_1 v_1+t_2 v_2+...+t_n v_n)+(a_1 v_1+a_2 v_2+...+a_n v_n)$ 。前一个括号中向量即为 $t$，后一个括号中向量即为 $v$ 。

接下来证明唯一性，若$\alpha_i$ 还可分解为 $\alpha_i=t_i^{'}+a_i^{'}$ ，那么对每个 $i$有$
t_i+a_i=t_i^{'}+a_i^{'}$ 。即 $t_i-t_i^{'}=a_i-a_i^{'}$ 为整数。由于 $0\leq t_i<1, 0\leq t_i^{'}<1$ ，可知 $t_i=t_i^{'},a_i=a_i^{'}$，即分解唯一。

### 格密码学中的几种常见问题

1. 最短向量问题（The Shortest Vector Problem，SVP）：即在格中寻找一个最短非零向量$v$，这里的长短使用2范数，即欧式范数。 $||v||=\sqrt{x_{1}^{2}+x_{2}^{2}+...+x_{n}^{2}}$。
2. 最近向量问题（The Closest Vector Problem，CVP）：给定一个向量 $w$ ，在格中寻找一个向量 $v$ ，使得 $||w-v||$ 最小，即在格中寻找最接近 $w$的向量。

这两种问题都具有多解性，一个格里完全可以有多个最短向量以及多个和给定向量最接近的向量，例子很好想。同时，CVP问题可以转化为SVP问题；这两类问题还是格密码学中最基础的两类问题，许多变体问题可以从中衍生出来。例如如下两种衍生问题：

3. 近似最短向量问题（Approximate Shortest Vector Problem，apprSVP）：对于维数$n$ ，考虑依赖于维数的常数 $\psi(n)$
使得 $||v||\leq \psi(n)||v||_{shortest}$ 。

4. 近似最近向量问题（Approximate Closest Vector Problem，apprCVP）：对于维数 $n$ ，考虑依赖于维数的常数$\psi(n)$
，寻找 $\psi(n)||w-v||$。

这些问题都是NP问题，即在多项式时间内不知是否可解的问题，我们构造的所有格密码系统都与上述问题中的某一类等价，也就是说这些密码系统都是NP问题，这样就保证了密码系统的安全性。

## 3. 格密码学中基的选择

从方便理解和计算的角度来说，最好的基当然是正交的，但是很多时候近似正交的基也方便计算**。我们把近似正交基的基称作“好的”，而那些与正交基相差甚远的基称作“坏的”。** 直观示意如下：

![](https://picx.zhimg.com/v2-770fe232cac6c123097cb17aae0858ef_1440w.jpg)

我们需要使用一种量化的方法来度量一种基的选择是否是好的，我们使用**哈达玛比值（Hadamad ratio）来量化：记$\mathcal{H}(\mathcal{B})=(\frac{det(L)}{||v_1||||v_2||...||v_n||})^{\frac{1}{n}}$。**由于 $det(L)$ 是正的，结合线性代数中行列式的意义，可知 $0<\mathcal{H}(\mathcal{B})\leq 1$ 。

### 埃尔米特（Hermite）定理及其改进

**埃尔米特定理：每一个$n$ 维格 $L$ 中都存在一个非零向量 $v$ 满足 $||v||\leq \sqrt{n}\\ det(L)^{\frac{1}{n}}$ 。**

为了证明这个定理，首先需要证明一个结论，这个结论被称作闵可夫斯基（Minkowski）定理。

**闵可夫斯基定理：$L\subset R^n$ 且是一个 $n$ 维格，$S$ 是 $R^n$ 上的一个有界对称凸集且满足 $Vol(s)>2^n\\ det(L)$ ，那么 $S$中包含一个 $L$ 内的向量。如果 $S$ 是一个闭集，那么就有 $Vol(s)\geq2^n\\ det(L)$ 。**

证明： $\mathcal{F}$ 是 $L$ 中的基本域，那么 $S$ 中任何一个向量 $a$ 都可以表示表示成 $a=v_a+w_a$ 的形式，其中 $v_a \in L,w_a\in \mathcal{F}$ 。

接下来考虑集合 $\frac{1}{2}S=\{ \frac{1}{2}a|a\in S \}$ ，那么有 $Vol(\frac{1}{2}S)=\frac{1}{2^n}Vol(S)>det(L)=Vol(\mathcal{F})$ ，即$\frac{1}{2}S$ 中必存在两个不同的向量 $a_1,a_2$使得 $a_1=v_1+w,a_2=v_2+w$ 。其中 $v_1,v_2\in \frac{1}{2}S,w\in \mathcal{F}$ 。那么 $0\ne a_1-a_2=v_1-v_2\in S\cap L$ 。

闭集的情况需要使用分析学中的一个常见技巧，考虑 $v\in \displaystyle\mathop{\cap}_{k=1} ^{+\infty}(1+\frac{1}{k})S$ ，再结合以上证明过程即可。

现在开始证明埃尔米特定理：

现在有一个格 $L$ ，满足$det(L)^{\frac{1}{n}}=B$ 。考虑集合 $S$ 使 $S=\{(x_1,x_2,...x_n)\in R^n：-B\leq x_i\leq B, 1\leq i \leq n \}$ ，这里有 $Vol(S)=2^ndet(L)$。那么根据闵可夫斯基定理，存在$
0\ne a \in S\cap L$ 。记 $a=(a_1,a_2,...a_n)$，那么有$||a||=\sqrt{a_{1}^{2}+a_{2}^{2}+...+a_{n}^{2}}\leq \sqrt{n}B=\sqrt{n}det(L)^{\frac{1}{n}}$ ，结论得证。

观察以上证明过程会发现构造出的 $S$ 是个n维正方体，如果把n维正方体换成n维球，不等式的界还可以进一步优化。由于以点a为球心的n维球的体积公式为$Vol(B_R(a))=\frac{\pi^{2/n}R^n}{\Gamma(1+\frac{n}{2})}$
，结合伽马函数性质，得 $Vol(B_R(a))^{\frac{1}{n}}\approx \sqrt{\frac{2\pi e}{n}}R$ ，当n非常大时，结合用n维正方体时的公式可以得出 $||v||<\sqrt{\frac{2n}{\pi e}}(det\\ L)^{\frac{1}{n}}$ 。 $\sqrt{\frac{2}{\pi e}}\approx 0.484$ ，这就进一步缩小了不等式的界。

## Babai算法

这个算法用于解决CVP问题，**在好的基上效果很好，但在坏的基上效果很差，几乎没用。**

**Babai算法：已知$L\subset R^n$ 是一个n维格，其基为 $v_1,v_2,...v_n$ 。$w\in R^n$ 是一个随机向量，记 $w =t_1v_1+t_2v_2+...+t_nv_n$。那么当$
L$ 的基足够接近正交基时，向量 $v=\lfloor t_1 \rceil v_1+\lfloor t_2 \rceil v_2+...+\lfloor t_n \rceil v_n$ 为 $L$中最接近$
w$ 的向量，其中 $\lceil t_i \rfloor$ 表示数轴上与 $t_i$最接近的整数。**

证明思路很好想，如果$v_1,v_2,...v_n$是一组正交基，那么结论是平凡的，当这组基与正交基的差距在一定限度内，结论也是成立的。

接下来的GGH格密码系统就是运用了Babai算法。

## 4. GGH密码系统

GGH密码系统在1990年代中期由Goldreich, Goldwasser, Halevi提出，因此被称作GGH系统。

Alice首先需要选择一组线性无关的向量$v_1,v_2,...v_n\in R^n$，用这组向量构造出格 $L$，并计算这组向量的哈达玛比值使得这组向量接近正交基。这组向量就是Alice的私钥，我们用矩阵 $V$来表示，$V$中的第$i$ 行即为向量$v_i$ 。$V$ 可以用随机取样的方法来构造。

接下来，Alice需要找到一个矩阵$U$ ， $U$ 中的每一个元素都是整数且 $det(U)=\pm 1$ 。接下来Alice需要计算 $W=UV$， $W$ 即为公钥，由线性代数知识，其中的所有行向量 $w_1,w_2,...w_n$ 是 $L$ 的另一组基。一般来说，公钥都是坏基。

现在Bob想给Alice送信，他手上有密文$m$ ，其中 $m$ 是一个n元整数向量。接下来Bob再取一个随机向量 $r$ 做为干扰项，向量 $r$ 的每个分量都比较小（例如可以在 $(-\delta, \delta)$ 之间随机取样）。接下来Bob计算：$e=mW+r$。 $e$ 即为密文。

Alice收到密文之后，首先利用Babai算法找到与 $e$ 最接近的格内向量 $v$ 。由于 $r$ 是一个很小的干扰向量，因此 $v=mW$ ，即 $m=vW^{-1}$ ，Alice可以轻易得到原文 $m$ 。

与此同时Eve也在解密，但是她不知道私钥 $V$ ，因此她只能在公钥 $W$ 上运行Babai算法，由于 $W$ 是个坏基组成的矩阵，Eve最后得出的结果会与原文差之千里。这样就构建了一个成功的密码系统。

当然，GGH还有另一种变体，即Bob调换 $m$ 和 $r$ 的位置，最后计算出的密文是 $e=rW+m$，这种情况Alice最后会用 $m=e-rW$ 复原原文。

## 5. 模p意义下的卷积多项式环及NTRU密码系统

### 卷积多项式环

环的基本性质可参考密码学（一）：基础数学知识与密码学的简单介绍 - 语冰的夏虫君的文章 - 

首先定义最高次数为$N$ 的商环： $R=\frac {\mathbb{Z}[x]
}{x^N-1}$ 。

其实就是对于所有多项式中的每一项 $x^k$ ，将$x^k$ 变为 $x^{k-tN}$ ，其中 $t$ 为正整数， $0\leq k-tN\leq N-1$ 。例如 $x^{N+1}+x^2+1$在 $R$ 内就是 $x^2+x+1$ 。

接下里定义模$p$ 意义下的多项式环： $R_p=\frac{(\mathbb{Z}/p\mathbb{Z})[x]
}{x^N-1}$ 。

即对每一个系数都模$p$ 。例如当 $p=3，N=3$ 时，多项式 $4x^2+3x+1$ 在 $R_p$ 内就是 $x^2+1$ 。

$R_p$ 内元素都满足 $a_0+a_1x+...+a_N x^{N-1}$ 的形式，其中 $a_i$ 为正整数且 $0\leq a_i\leq p-1$ 。

易于验证 $R_p$ 是环。

“卷积多项式环”中的“卷积”来源于这条性质：对于 $a(x)\in R_p,\\ b(x)\in R_p$ 。 $a(x)\times b(x)=c(x)\in R_p$ ，有 $c_k=\sum\limits_{i+j\equiv k (mod\\ N)}a_i b_{k-i}$。

展开即可证明结论，多项式乘积的系数由卷积得到，由此得名。

**接下来介绍一个操作：中心化(Center-lift)多项式。**

对于 $a(x)\in R_p$ ，存在唯一的一个 $a^{'}(x)\in R_p$ 满足 $a^{'}(x)\equiv a(x) \\ (mod\\ p)$ ，且 $-\frac{p}{2}<a_{i}^{'}\leq \frac{p}{2}$ 。那么 $a^{'}(x)$ 就是 $a(x)$ 的中心化多项式。

例如 $a(x)=5+3x − 6x^2 + 2x^3 + 4x^4 ∈ R_7$ ，那么 $a^{'}(x)=−2+3x + x^2 + 2x^3 − 3x^4$ 。中心化本质上是对多项式做一种对称操作。

**但是，中心化后的多项式不再满足如下性质：**

在环中，有 $a(x)\times b(x)=c(x)$ ，但是中心化后的 $a^{'}(x)\times b^{'}(x)=c^{'}(x)$ 未必成立，见下例：

$a(x)=5+3x − 6x^2 + 2x^3 + 4x^4 ∈ R_7$ ， $b(x)=3+5x^2 − 6x^3 + 3x^4 \in R_7$ 。

此时 $a^{'}(x)\times b^{'}(x)=20x + 10x^2 − 11x^3 − 14x^4$ ，但是 $c^{'}(x)=(a(x)\times b(x))^{'}= −x + 3x^2 + 3x^3$ 。

**模p意义下的卷积多项式还有一条性质与常规多项式不同，那就是更多元素存在乘法逆元。**

例如在 $R_7$ 中， $1+x^2+x^3$ 与 $1+x+x^4$ 互为乘法逆元。

**定理：$p$ 是一个素数，对于$a(x)\in R_p$ ，其有乘法逆元的充要条件是 $gcd(a(x),x^N-1)=1$。**以上所有运算都是在$
(\mathbb{Z}/p\mathbb{Z})[x]$中。

证明：使用推广的欧几里得算法，有$a(x)u(x)+v(x)(x^N-1)=gcd(a(x),x^N-1)$。充分性得证。

若$a(x)$ 有逆元，那么记为 $u(x)$ ，即 $a(x)u(x)-1=0=v(x)(x^N-1)$，变形得$a(x)u(x)-v(x)(x^N-1)=1$ ，即$gcd(a(x),x^N-1)=1$，必要性得证。

### NTRU密码系统

NTRU密码系统也是在1990年代中期出现的，NTRU的本意为”我们是数字专家（Number Theorists R us）"。它所在的论文原文名为“在环上构建的一种公钥密码系统（a ring-based public key cryptosystem）”，从名字就能看出来它与之前密码系统的差异。从前不管是整数上的Elgamal，RSA，还是椭圆曲线上的ECC，它们都是群上的密码系统。环与群的一项核心差异就是：群只有一种运算，而环有两种。NTRU，就是在卷积多项式环上构建的一种密码系统。

以下为NTRU系统的构建过程：

首先，Alice需要确定一组参数 $(N,p,q,d)$ 并公布，其中 $N$ 是素数且 $gcd(N,q)=gcd(p,q)=1$ 。（原因之后会讲）。

记 $R=\frac{\mathbb{Z}[x]}{x^N-1}$，$$R_p=\frac{(\mathbb{Z}/p\mathbb{Z})[x]}{x^N-1}，R_q=\frac{(\mathbb{Z}/q\mathbb{Z})[x]}{x^N-1}$。

为了构建NTRU密码系统，我们需要对私钥做一些限制，为方便叙述引入记号$\mathscr {\tau}(d_1,d_2)$ ，其意义为对于$R$中的多项式，所有满足有 $d_1$ 个系数为 1 ，有 $d_2$ 个系数为 -1 ，其余所有系数均为 0 的多项式组成的集合。例如当 N=11 时， $x^4-x^2+x-1\in \mathscr {\tau}(2,2)$ 。

接下来Alice随机选择两个多项式 $f,g$ 满足$f(x)\in \mathscr {\tau}(d+1,d)$ ， $g(x)\in \mathscr {\tau}(d,d)$ 。之后她需要计算出 $F_p(x)=f(x)^{-1}(mod\\ p)$ ， $F_q(x)=f(x)^{-1}(mod\\ q)$ 。（如果运气不好，有逆元不存在的情况出现的话，Alice重新挑一个 $f$就好了）。

为什么用$f$ 来求逆元而不是用 $g$ ，这是因为根据 $g$ 的定义有 $g(1)=0$ ，即 $x-1|g(x)$ ，而 $x-1|x^N -1$$对所有正整数$
N$ 成立，这使得 $(g(x),x^N-1)\ne 1$ ， $g$就不存在逆元。

之后，Alice计算出$h(x)=F_q(x)\times g(x) (mod\\ q)$。$h(x)$就是公钥。

Bob手上的原文是一个中心化的多项式$m(x)$ ，其中原文信息对应多项式系数 $m_i$，满足$-\frac{p}{2}< m_i\leq \frac{p}{2}$。为了加密原文，Bob需要找一个随机多项式$r(x)\in \tau (d,d)$。之后计算$e(x) \equiv p\times h(x)\times r(x)+m(x) (mod\\ q)$。$e(x)$即为密文。

为了解密，Alice首先需要计算$a(x) \equiv f(x)\times e(x) (mod\\ q)a(x) \equiv f(x)\times e(x) (mod\\ q)$，接下来计算 $b(x) \equiv F_p(x)\times a(x) (mod\\ p)$。

其过程如下： $a(x) \equiv f(x)\times e(x) \equiv p\times g(x)\\times r(x)+f(x)\times m(x) (mod\\ q)$

代入 $b(x)$ 内有 $b(x)\equiv F_p(x)\times (p\times g(x)\times r(x)+f(x)\times m(x) )\equiv m(x) (mod \\ p)$ 。

但是，这个过程中存在一个问题，那就是在第一部模 q 的过程中，信息可能会受到干扰。具体来说，考虑下面这个例子：假设所有的多项式都只有常数项，我们适当选择数使得 a=q+1 ,在取模后 a 就成了 1 ，此时 $b=F_p$ 。但如果直接用 q+1 模 p ，当 p=q-2 时， $b=3F_p$ 。这就可能在解密过程中对原信息造成干扰，因此需要一些条件辅助。

考虑 $a(x)  \equiv p\times g(x)\times r(x)+f(x)\times m(x) (mod\\ q)$ ，由于 $g,r \in \tau (d,d)$ ，那么 $g\times r$ 的系数和最大为 $2d$。而$r \in \tau (d+1,d)$ 且 $m(x)$的系数在$-\frac{p}{2}$ 与 $\frac{p}{2}$$之间。即$f\times m$ 最大值为 $(2d+1)\times \frac{p}{2}$ 。两项相加得 $(3d+\frac{1}{2})p$。由于$a(x)$ 运算式中所有多项式都可以视作中心化多项式，为了保证取模 $q$运算时不损失信息，有$\frac{q}{2}>(3d+\frac{1}{2})p$，**即 $q>(6d+1)p$ 。满足该不等式时Alice的解密过程一定能保证 $b(x)=m(x)$ 。**

实际上，为了让密码系统失效的条件非常苛刻。即使参数选择不满足上面的不等式，密码系统失效的概率也是很小的，当 N 比较大时，这个概率大约是 $2^{-80}$ ，几乎可以认为密码系统不会在解密过程中出现问题。

接下来解释一个前面的问题，为什么构建系统时$N$ 是素数且 $gcd(N,q)=gcd(p,q)=1$ 。

如果 N 不是素数，那么就可以表示为如下形式N=pq ，即多项式可分解为 $x^N-1=(x^p-1)k(x)$的形式，这会导致Eve不需要用大数N，用小一些的数p就可以进行破解系统的尝试。

由于$e(x) \equiv p\times h(x)\times r(x)+m(x) (mod\\ q)$，当$gcd(p,q)\ne 1$时，那么Eve肯定能找到一个$k$ 满足 $q|kp$ 且 $q \nmid k$ ，等式两边乘 $k$后有 $k\times e(x) \equiv k \times m(x)\\  (mod \\ q)$ 。此时Eve可以直接绕过密码系统。

**接下来考虑Eve的破解方法**

Alice在构建NTRU系统时，有一个核心步骤就是构造公钥 $h(x)=F_q(x)\times g(x) (mod\\ q)$ 。结合$F_q(x)=f(x)^{-1}(mod\\ q)$，可知 $f(x)\times h(x)\equiv g(x)\\ (mod\\ q)$。也就是说Eve只要能找到$f(x)\in \mathscr {\tau}(d+1,d)$ ， $g(x)\in \mathscr {\tau}(d,d)$满足此式，她就有可能攻破系统。当然这个解不会是唯一的，因为若 $f$ 是解，那么 $x^k\times f$ 也是解，我们称这种情况为“旋转”。

下面的结论说明了，如果Eve猜出了一组 f,g ，那么基本可以确定这组多项式及其旋转就是Alice的私钥。

在大量的尝试中，我们发现 $F_p,F_q,h$ 的系数接近于均匀分布，这一点目前尚未有数学证明，但可以当作经验公式进行使用。

由于我们将系数分布视作均匀分布，那么对于 $f$ 的每一个系数，它只有$0,\pm 1$ 三种选择，多项式总共 N 个系数，那么概率即为 $(\frac{3}{q})^N$。且$
h$ 有 $C_{N}^{d}C_{N-d}^{d+1}$ 种选择。两者乘积 $(\frac{3}{q})^NC_{N}^{d}C_{N-d}^{d+1}$即为Eve猜出 f,g 的概率。当 N,q很大时，这个概率极其的小。这说明如果Eve猜出了满足等式的多项式，那么它极有可能就是私钥。

### NTRU密码系统的格表示

记$h(x)=h_0+h_1 x +...+h_{N-1} x^{N-1}$。

那么构造出矩阵$$  
M = \left( \begin{array}{cccc|cccc}
1 & 0 & \dots & 0 & h_0 & h_1 & \dots & h_{N-1} \\
0 & 1 & \dots & 0 & h_{N-1} & h_0 & \dots & h_{N-2} \\
\vdots & \vdots & \ddots & \vdots & \vdots & \vdots & \ddots & \vdots \\
0 & 0 & \dots & 1 & h_1 & h_2 & \dots & h_0 \\
\hline
0 & 0 & \dots & 0 & q & 0 & \dots & 0 \\
0 & 0 & \dots & 0 & 0 & q & \dots & 0 \\
\vdots & \vdots & \ddots & \vdots & \vdots & \vdots & \ddots & \vdots \\
0 & 0 & \dots & 0 & 0 & 0 & \dots & q \\
\end{array} \right)
  $$。

该矩阵可以简化为
$$
M=\left(     \begin{array}  {cccc|cccc}    
I & h \\      
0 & qI \\     
\end{array} \right)
$$。由之前所述NTRU构造$f(x)h(x)=g(x)+qu(x)$，有$(f,-u)M=(f,g)$。

## 6. 用于破解格密码的LLL算法

从之前的GGH密码系统中我们看出，其核心在于密码所有者Alice掌握着一组好基，而攻击者Eve只有一组公布的坏基。因此Alice可以迅速的解决SVP和CVP问题，而Eve却对着坏基束手无策。有没有什么办法能把坏基变成好基呢，LLL算法就是干这个的。它于1982年由Lenstra, Lenstra和Lovasz提出，故名为LLL算法。但这个算法最早的思想在19世纪就已经出现了，高斯给出了二维平面上的算法。同时这种方法跟线性代数中将任意一组基变为正交基的格拉姆-施密特(Gram–Schmidt)方法强相关。**格拉姆-施密特方法如下所示：**

**对于n维线性空间的任意一组基$(v_1,v_2,...v_n)$，考虑向量 $v_i^{*}=v_i-\displaystyle \sum_{j=1}^{i-1}\mu_{ij}v_j$ 。其中 $\mu_{ij}=\frac{v_i*v_j^{*}}{||v_j^{*}||^2}$。直接代入内积定义即可证明 ![(v_1^*,v_2^*,...v_n^*)$ 是一组正交基。**

### 二维平面上的高斯简化算法

在二维平面内，运用格拉姆-施密特方法，有 $v_2^{*}=v_1-\frac{v_1*v_2}{||v_2||^2}v_2$。但是$\frac{v_1*v_2}{||v_2||^2}$ 可能不是整数，所以考虑 $m=\lceil\frac{v_1*v_2}{||v_2||^2}\rfloor$，这里 $\lceil \rfloor$ 意义和Babai算法中意义相同，都是指数轴上与符号内的数相距最近的整数。

**高斯简化算法步骤如下：首先比较$||v_1||,||v_2||$ 大小。为方便起见，不妨都设为$||v_2||<||v_1||$ ，之后计算$m=\lceil\frac{v_1*v_2}{||v_2||^2}\rfloor$。如果 $m=0$ ，那么 $v_1,v_2$即为所得结果，如果$
m\ne 0$ ，记 $v_2-mv_1$为新的 $v_2$ ，重复上述过程。最后得到的** $v_1$**就是最开始的两个向量张成的格中的最短向量。**

由于最后得到的$m=0$，即 $\left| \frac{v_1*v_2}{||v_2||^2} \right|\leq\frac{1}{2}$ ，结合内积定义，可知 $v_1$与$
v_2$的夹角 $\theta$满足 $\frac{\pi}{3}\leq \theta \leq \frac{2\pi}{3}$ 。

证明：对格中任意向量 $v$ ，记 $v=a_1v_1+a_2v_2$ ，结合 $||v_2||<||v_1||$ 和 $\left| \frac{v_1*v_2}{||v_2||^2} \right|\leq\frac{1}{2}$ 有

$\begin{eqnarray}     ||v||^2&=&||a_1v_1+a_2v_2||^2   \\\\ &=&  a_1||v_1||^2+2a_1 a_2(v_1\cdot v_2)+a_2^2||v_2||^2 \\\\ &\geq&  a_1^2||v_1||^2-2|a_1 a_2|*|v_1\cdot v_2|+a_2^2||v_2||^2 \\\\ &\geq& a_1^2||v_1||^2-|a_1 a_2|*||v_1||^2+a_2^2||v_2||^2 \\\\ &\geq& a_1^2||v_1||^2-|a_1 a_2|*||v_1||^2+a_2^2||v_1||^2 \\\\ &=& (a_1^2-|a_1 a_2|+a_2^2)||v_1||^2 \end{eqnarray}$

配方可知 $a_1^2-|a_1 a_2|+a_2^2=\frac{3}{4}a_1^2+(\frac{1}{2}a_1-a_2)^2$ 。当且仅当 $a_1=a_2=0$ 时 $||v||<||v_1||$ 。即 $||v_1||$ 是格内最小向量。

### 一般情况下的LLL算法

我们想要在n维空间内仿照2维空间的高斯简化法，但是在n维空间内，我们不能像2维空间那样直接操作。为了方便叙述，我们先引进一个概念：LLL约简（LLL reduced）。

设 $\mathcal{B}=(v_1,v_2,...v_n)$ 是格$L$ 的基， $\mathcal{B^*}=(v_1^*,v_2^*,...v_n^*)$是 $\mathcal{B}$ 经过格拉姆-施密特正交化后的基，如果 $\mathcal{B}=(v_1,v_2,...v_n)$ 满足如下条件，则称其为LLL约简基。

（1）： $|\mu_{ij}|=\frac{|v_i*v_j^*|}{||v_j^*||^2}=\\frac{1}{2},1\leq i<j\leq n$

（2）： $||v_i^*||^2\geq (\frac{3}{4}-\mu_{i,i-1}^2)||v_{i-1}^*||^2, 1<i\leq n$

这两条其实隐含了LLL的核心思路，那就是控制不同向量间的夹角，使它们大于一个下限。为了达成这个目标，我们还是基于格拉姆-施密特方法，采用高斯二维情况中的系数取整方式进行操作。只不过在n维情况中，不能再直接对所有向量进行操作，而是需要对向量进行排序，先挑那些性质比较好的来操作。

**LLL算法具体操作如下：**

**对于格** L **的基$(v_1,v_2,...v_n)$$
**

**（1）：记** $k=2, v_1^*=v_1$ **，对所有的 $k\leq n$ 进行操作。**

**（2）：计算** $v_k-\displaystyle \sum_{j=1}^{k-1}\lceil \mu_{kj}\rfloor v_j$ **，将此值记为新的 $v_k$ 。**

**（3）：如果** **$||v_k^*||^2\geq (\frac{3}{4}-\mu_{k,k-1}^2)||v_{k-1}^*||^2$，那么记 $k+1$ 为新的 $k$;如果** **$||v_k^*||^2< (\frac{3}{4}-\mu_{k,k-1}^2)||v_{k-1}^*||^2$，那么调换 $v_{k-1}$ 与 $v_k$ 的顺序，并记 $max(k-1,2)$ 为新的 $k$ 。**

**重复以上过程，最后得到的$(v_1,v_2,...v_)$ 就是LLL约简基(LLL reduced base)。**

核心思路就是不断调整向量顺序进行近似正交化，由于LLL算法严重依赖向量顺序，如果原矩阵中出现了行变换的情况，例如调换第一行与第二行的顺序。那么两个矩阵用LLL算法约简后的矩阵很可能是不一样的。详细介绍过程可参见原论文：[https://www.cs.cmu.edu/~avrim/451f11/lectures/lect1129_LLL.pdf](https://link.zhihu.com/?target=https%3A//www.cs.cmu.edu/~avrim/451f11/lectures/lect1129_LLL.pdf)。

该算法复杂度为 $\mathcal{O}(n^6 (log\\ B)^3)$ ，其中 $B=max||v_i||$ ，这说明LLL是一个多项式时间算法。

利用LLL算法，我们提到的Knapsack，GGH以及NTRU问题就有了一种通用解法。只需要将这些密码系统的公钥矩阵用LLL算法进行约简，就可以得到一组好基，这样就很大程度上降低了破解难度。

该算法还有很多优化思路，例如原本是交换 $v_k$ 与 $v_{k-1}$ ，可以尝试依照某种方式交换 $v_k$ 与 $v_j.j\leq k-1$ 。这种拓展方法就是LLL-BKZ算法，这里暂且不过多介绍。

## 7\. 简单总结

相比传统的密码机制，格密码的优点就是迅速快捷。对于像RSA,ECC这样的传统密码来说，如果信息是k个bit，加密和解密耗费的时间基本都是$\mathcal{O}(k^3)$
，但是格密码耗费的时间却是$\mathcal{O}(k^2)$ 。而且格密码是基于矩阵的，这使得程序处理更加方便（想想Matlab的特点是什么）。但是，格密码学还是一个新兴领域，很多原理目前还没有被彻底搞清楚，因此其实际应用范围没有传统密码那样广泛。