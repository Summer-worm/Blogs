---
title: 密码学（二）：公钥私钥系统，Diffie-Hellman密码系统,EIGamal密码系统以及离散对数问题
date: 2025-09-09
categories:
  - Mathematics
mathjax: true
---

## 公钥系统（Public Key Cryptosystem）的诞生与基本设定：

1976年，两位大佬Whitfield Diffle和Martin Hellman发表了一篇名为“密码学的新方向”(New Direction in Cryptography)的文章。他们在这篇文章里提出了现代密码学公钥系统的概念，简称为PKC。他们发表的文章其实比较好读，具有高中数学水平的读者就可以看懂他们的意思。文章链接[https://ee.stanford.edu/~hellman/publications/24.pdf]

在他们这篇文章问世后，很快，就陆续有了一些实践算法问世。这些实践算法中，最有名的两个算法，就是RSA算法和Knapsack Scheme。经过长期实践，RSA算法最后胜出，成为到目前为止仍然广泛运用的算法。但是Knapsack Scheme算法在后续的密码学研究之中，依然有重要的作用。

公钥私钥系统的组成是这样的，Alice和Bob共同商议一个公钥 $K_{pub}$ ，而且每个人手上都有对应这个公钥的私钥 $K_{pri1},K_{pri2}$，现在Alice想向Bob发信息，那么她先用自己手上的私钥 $K_{pri1}$ 对自己的原文 $M$ 加密，再把加密后的密文 $S$ 发送给Bob，Bob利用自己手上的私钥 $K_{pri2}$，可以很轻松地得到原文 $M$。在传输过程中，公钥 $K_{pub}$和密文 $S$是公开的。但是，根据之前对安全密码系统的假设，即使Eva知道所有的公开信息与加密解密流程，对于缺少私钥的她而言，得到原文依然是一件困难的事。

对于现在常用的密码系统而言，公钥私钥系统的构建都依赖于这样一个数学上的事实：”非常大的数难以进行素因数分解“。迄今为止还没有一个快速分解素因数的普遍算法，只有在某些特殊情况下可以快速分解素因数，之后的笔记中会提一些这样的现象。同时，在很多情况下，分解素因数与素数分布有关，在RSA密码系统中，就会见到”如果黎曼猜想成立，那么该算法就会给出一个上界“之类的定理。某种意义上讲，密码学就是一个数论的应用学科。

### Diffie-Hellman密码系统:

这个密码系统大概是最简单的公钥密码系统，我们还是从Alice和Bob的事情来举例：

Alice和Bob需要共享一个相同的信息，首先ta们需要把这个相同的信息对应成一个正整数（比如用ASCII表），之后ta们可以采用如下加密方法，这种密码体系就是Diffie-Hellman密码系统。

首先，Alice和Bob选定一个大素数 $p$，再选定 $p$的一个原根 $g$。把 $(p,g)$当作公钥发布。

之后，Alice随便选一个正整数 $a$，计算 $g^{a}\equiv A\\ (mod \\ p)$,并将数字 $A$发给Bob。

Bob也做同样的操作，计算 $g^{b}\equiv B\\ (mod \\ p)$，并将数字 $B$发给Alice。

Alice和Bob分别对 $B$和 $A$如此操作：计算 $B^{a} \equiv (mod\\ p)$与 $A^{b}\equiv\\ (mod\\ p)$这两个数在模 $p$运算下相等，这个模运算后的数就是共享的信息。原因如下：

$B^{a}\equiv\\ g^{ba} \equiv g^{ab} \equiv A^{b}(mod\\ p)$。

Diffie-Hellman密码系统其实不是一个完整的密码系统，因为它只是交换随机数 $A$与 $B$，没有交换密码系统中的特征值，接下来的ELGamal密码系统就会展现更多公钥私钥密码系统的特点。

### **ElGamal 密码系统：**

这个密码系统是在Diffie-Hellman密码系统之上诞生的，有很多实际应用。

依然是Alice和Bob两个人，他们依旧选定一个大素数 $p$，再选定 $p$的一个原根 $g$。

但接下来就是有差异的地方了，这回让Bob给Alice发消息，但是在此之前，Alice还要做这样一件事：

随机选择一个正整数 $a,(1\leq a \leq p-1)$。我们把 $a$称为密钥。计算 $g^{a}\equiv A\\ (mod \\ p)$。把 $A$当作公钥发布。

也就是说，Eva实际上知道三个数 $(p,g,A)$。

之后Bob将密文 $m$加密，加密方法如下：

首先随机选取一个正整数 $k$，我们称 $k$为临时密钥（Ephemeral Key）。

计算 $c_{1}=g^{k}\\ (mod \\ p),c_{2}=mA^{k}\\ (mod \\ p)$。把密文 $(c_{1},c_{2})$发给Alice。

Alice收到密文后，只需要计算 $(c_{1}^{a})^{-1}c_{2}\\ (mod \\ p)$即可。因为 $m=(c_{1}^{a})^{-1}c_{2}\\ (mod \\ p)$。

$p$ 必须足够大，使得 $p$大于 $m$。

原因解释：

$(c_{1}^{a})^{-1}c_{2}\equiv (g^{ak})^{-1}(mA^{k})\equiv m(g^{ak})^{-1}(g^{ak})\equiv m\\ (mod \\ p)$。

### **离散对数问题：**

现在我们站在Eva的角度上看问题，如果她想要破解上面的两个密码系统，她会面临什么问题？

对于Diffie-Hellman密码系统，她面临的问题是：

已经知道了原根 $g$与素数 $p$，以及公钥 $A$。现在需要找到一个正整数 $a$使得 $g^{a}\equiv A\\ (mod \\ p)$。这个问题即为离散对数问题（Discrete Logarithm Problem）。

先分析算法复杂度，如果一个一个尝试的话，这个问题的算法复杂度，很明显是 $O(N)$的阶数。如果 $g$是原根的话，那么算法复杂度就是 $O(p)$。

有如下办法来降低算法复杂度，这个办法被称作**大步小步算法** （**Shank's Babystep-Giantstep Algorithm）** 。采用这种办法，可以把算法复杂度降到 $O(\sqrt{N}\\ ln\\ (N))$。步骤如下：

（1）：选取正整数 $n$ 使得 $n=\lfloor \sqrt{N}\rfloor +1$。这里 $\lfloor x\rfloor$ 表示对 $x$ 向下取整。

（2）：计算两个数组： $e,g,g^{2},...,g^{n}$ 与 $h,hg^{-n},hg^{-2n},...hg^{-n^{2}}$ 。

（3）：找到对应的 $i,j$ 使得 $g^{i}=hg^{-jn}$ 。

（4）：那么对应 $g^{a} \equiv A\\ (mod \\ p)$ 的解即为 $a=i+jn$

步骤（1）需要计算 $2n$ 次，对于步骤（3），由于排序算法的算法复杂度中间值是 $O(n\\ ln \\ (n))$ ， $n=\sqrt{N}$ ，那么这个算法的复杂度就是两者之和，即 $O(\sqrt{N}\\ ln\\ (N))$ 。

接下来考虑一种特殊情况，如果 $g$ 的阶数 $N$ 能被分解成若干个小素数之积的话，那么Eva的解密过程将会轻松许多。这种情况有一个对应的算法，称为**Pohlig-Hellman Algorithm** ：

对于一个群 $G$ ， $g\\in G$ ，若 $g$ 的阶数 $N$ 可被分解为若干素数的乘积 $N=p_{1}^{e_{1}}p_{2}^{e_{2}}...p_{n}^{e_{n}}$ 的话。那么离散对数问题 $g^{a}\equiv A\\ (mod\\ p)$ 可以用如下步骤解决：

（1）：对于 $1\leq i \leq n$ ，有 $g_{i}=g^{\\frac{N}{q_{i}^{e_{i}}}},h_{i}=h^{\\frac{N}{q_{i}^{e_{i}}}}$ 。我们需要计算出 $g_{i}^{y_{i}}\equiv y_{i}\\ (mod\\ N)$ 。

（2）：用中国剩余定理，解决 $a\equiv y_{1}(mod \\ q_{1}^{e_{1}}),a\equiv y_{2}(mod \\ q_{2}^{e_{2}}),...a\equiv y_{n}(mod \\ q_{n}^{e_{n}})$ 的同余方程组。

所以Alice和Bob在选取素数 $p$ 时，应当尽量避免 $p-1$ 能被分解成小素数乘积的情况。

### 程序练习：

文本是Jupyter Notebook，语言依旧是Python3.10.7，代码可以在我的Github[GitHub - Summer-worm/Cryptography: Some works I do when I study cryptography](https://link.zhihu.com/?target=https%3A//github.com/Summer-worm/Cryptography)中的Homework2与Homework3中找到。

1：尝试自己编写一个Diffie-Hellman密码系统，并代入以下几组数验证：

$p = 2712691, g = 2, a = 2553,b = 26511$

以及

$p = 340282366920938463463374607431768211507$

$g = 121770841829326452690259895862715513623$

$a = 21712651827515182$

$b = 274812741241924192499$

2：尝试自己编写一个EIGmal密码系统，并解出如下密文的原文：

$p = 286197821500073589067075140527$

$g = 195051999861158821970552089016$

私钥 $a = 7712654356741$

密文 $\[223905580785475751236633059935, 197494619985708086124722797272\$]

3：编写一个函数pohligHellman(g,h,p,orderFactors)，orderFactors是阶数N的素因数表，一般用一个链表表示，例如30的orderFactors就是[2，3，5]。试解决如下问题（这个题需要很多前置步骤，建议把大步小步算法和中国剩余定理的求解过程分别编成函数放在外面，以便调用）：

$p = 2189248127867$ ， $g = 1267362$ ， $h = 1244880003213$

且 $p − 1 = 2 · 29 · 2459 · 15350003$ 。

最后来一个加强版的：

$p = 286197821500073589067075140527$

$g = 195051999861158821970552089016$

$h = 232260532812121798828459018892$

$p − 1 = 2 · 29 · 167 · 17167 · 40450123061 · 42550787743$